<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mappa Interattiva</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/ol@8.1.0/ol.css">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            height: 100vh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            background-color: #f5f5f5;
        }
        
        .header-controls {
            background-color: #2c3e50;
            color: white;
            padding: 10px 15px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }
        
        .control-group {
            display: flex;
            align-items: center;
            gap: 20px;
            flex-wrap: wrap;
        }
        
        .slider-container {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .slider-container label {
            font-size: 14px;
            min-width: 120px;
        }
        
        .slider-value {
            min-width: 60px;
            text-align: right;
            font-size: 14px;
        }
        
        input[type="range"] {
            width: 150px;
        }
        
        .container {
            display: flex;
            flex: 1;
            flex-direction: column;
        }
        
        .ground-view {
            flex: 1;
            background-color: #87CEEB;
            position: relative;
            overflow: hidden;
            border-bottom: 2px solid #2c3e50;
        }
        
        .compass {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 80px;
            height: 80px;
            background-color: rgba(255, 255, 255, 0.8);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 0 10px rgba(0,0,0,0.3);
            z-index: 10;
        }
        
        .compass-arrow {
            width: 4px;
            height: 30px;
            background-color: #e74c3c;
            position: absolute;
            top: 10px;
            transform-origin: bottom center;
            transition: transform 0.1s ease;
        }
        
        .compass-north {
            position: absolute;
            top: 5px;
            font-weight: bold;
            color: #e74c3c;
        }
        
        .location-info {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background-color: rgba(255, 255, 255, 0.8);
            padding: 10px 15px;
            border-radius: 8px;
            box-shadow: 0 0 10px rgba(0,0,0,0.2);
            z-index: 10;
        }
        
        .marker {
            position: absolute;
            width: 12px;
            height: 12px;
            background-color: #e74c3c;
            border-radius: 50%;
            transform: translate(-50%, -50%);
            box-shadow: 0 0 5px rgba(0,0,0,0.5);
            z-index: 5;
        }
        
        .marker-info {
            position: absolute;
            background-color: rgba(255, 255, 255, 0.95);
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 12px;
            white-space: nowrap;
            transform: translate(10px, -50%);
            box-shadow: 0 0 5px rgba(0,0,0,0.3);
            pointer-events: none;
            z-index: 6;
            border: 1px solid #ddd;
        }
        
        .map-container {
            flex: 1;
            position: relative;
        }
        
        #map {
            width: 100%;
            height: 100%;
        }
        
        .accuracy-circle {
            border-radius: 50%;
            border: 2px solid rgba(0, 123, 255, 0.5);
            background-color: rgba(0, 123, 255, 0.1);
        }
        
        .controls {
            position: absolute;
            top: 10px;
            left: 10px;
            background-color: rgba(255, 255, 255, 0.95);
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 0 10px rgba(0,0,0,0.2);
            z-index: 10;
            width: 300px;
            border: 1px solid #ddd;
        }
        
        button {
            background-color: #3498db;
            color: white;
            border: none;
            padding: 8px 12px;
            border-radius: 4px;
            cursor: pointer;
            margin-right: 5px;
            font-size: 14px;
            width: 100%;
            margin-bottom: 8px;
            transition: background-color 0.3s;
        }
        
        button:hover {
            background-color: #2980b9;
        }
        
        #debugBtn.active {
            background-color: #e74c3c;
        }
        
        .status {
            margin-top: 10px;
            font-size: 12px;
            color: #7f8c8d;
        }
        
        .horizon {
            position: absolute;
            bottom: 0;
            width: 100%;
            height: 40%;
            background: linear-gradient(to bottom, rgba(135, 206, 235, 0) 0%, rgba(34, 139, 34, 0.7) 100%);
            z-index: 1;
        }
        
        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(255, 255, 255, 0.9);
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 0 10px rgba(0,0,0,0.3);
            z-index: 100;
        }
    </style>
</head>
<body>
    <div class="header-controls">
        <div class="control-group">
            <div class="slider-container">
                <label>Abitanti minimi:</label>
                <input type="range" id="minSizeSlider" min="0" max="100000" value="50000" step="1000">
                <div class="slider-value" id="minSizeValue">50.000</div>
            </div>
            <div class="slider-container">
                <label>Distanza massima (km):</label>
                <input type="range" id="maxDistanceSlider" min="0" max="20" value="2" step="0.1">
                <div class="slider-value" id="maxDistanceValue">2.0</div>
            </div>
        </div>
    </div>
    
    <div class="container">
        <div class="ground-view" id="groundView">
            <div class="compass">
                <div class="compass-north">N</div>
                <div class="compass-arrow" id="compassArrow"></div>
            </div>
            
            <div class="location-info">
                <div>Lat: <span id="currentLat">-</span></div>
                <div>Lon: <span id="currentLon">-</span></div>
                <div>Direzione: <span id="currentHeading">-</span>°</div>
            </div>
            
            <div class="horizon"></div>
        </div>
        
        <div class="map-container">
            <div id="map"></div>
            
            <div class="controls">
                <button id="centerMap">Centra Mappa</button>
                <button id="debugBtn">Modalità DEBUG</button>
                
                <div class="status" id="locationStatus">Caricamento dati in corso...</div>
            </div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/ol@8.1.0/dist/ol.js"></script>
    <script>
        // Variabili globali
        let userLocation = null;
        let userHeading = null;
        let map = null;
        let userMarker = null;
        let directionLine = null;
        let accuracyCircle = null;
        let townMarkers = [];
        let groundViewMarkers = [];
        let watchId = null;
        let compassWatchId = null;
        let debugMode = false;
        let minPopulationSize = 50000;
        let maxDistance = 2; // km
        let towns = [];

        // Inizializzazione della mappa
        function initMap() {
            map = new ol.Map({
                target: 'map',
                layers: [
                    new ol.layer.Tile({
                        source: new ol.source.OSM()
                    })
                ],
                view: new ol.View({
                    center: ol.proj.fromLonLat([12.4964, 41.9028]), // Centro su Roma
                    zoom: 6
                })
            });
            
            // Aggiungi controllo per il fullscreen
            map.addControl(new ol.control.FullScreen());
            
            // Centra la mappa sulla posizione corrente
            document.getElementById('centerMap').addEventListener('click', centerMapOnUser);
            
            // Aggiungi interazione per la modalità DEBUG
            map.on('click', function(evt) {
                if (debugMode) {
                    const coords = ol.proj.toLonLat(evt.coordinate);
                    userLocation = { lat: coords[1], lon: coords[0] };
                    updateUserLocationOnMap(userLocation.lat, userLocation.lon, 100);
                    updateGroundView();
                }
            });
            
            // Aggiungi interazione per ruotare la mappa in modalità DEBUG
            let rotationStart = 0;
            map.on('pointerdown', function(evt) {
                if (debugMode && evt.originalEvent.button === 2) { // Tasto destro
                    rotationStart = map.getView().getRotation();
                    document.addEventListener('pointermove', rotateMap);
                    document.addEventListener('pointerup', stopRotateMap);
                }
            });
            
            function rotateMap(evt) {
                if (debugMode) {
                    const deltaX = evt.movementX;
                    const newRotation = rotationStart - deltaX * 0.01;
                    map.getView().setRotation(newRotation);
                    userHeading = (newRotation * 180 / Math.PI + 360) % 360;
                    updateGroundView();
                }
            }
            
            function stopRotateMap() {
                document.removeEventListener('pointermove', rotateMap);
                document.removeEventListener('pointerup', stopRotateMap);
            }
            
            // Previeni il menu contestuale sul tasto destro
            map.getViewport().addEventListener('contextmenu', function(evt) {
                evt.preventDefault();
            });
        }

        // Carica i dati dei comuni italiani dalla nuova fonte
        async function loadTownsData() {
            try {
                document.getElementById('locationStatus').textContent = 'Caricamento dati comuni italiani...';
                
                // Usa la nuova fonte dati
                const dataUrl = 'https://axqvoqvbfjpaamphztgd.functions.supabase.co/comuni';
                
                const response = await fetch(dataUrl);
                
                if (!response.ok) {
                    throw new Error('Errore nel caricamento dati');
                }
                
                const data = await response.json();
                
                // Estrai i dati dei comuni con popolazione e coordinate
                towns = data.map(comune => ({
                    name: comune.nome,
                    lat: parseFloat(comune.coordinate.lat),
                    lon: parseFloat(comune.coordinate.lng),
                    population: parseInt(comune.popolazione) || 0,
                    provincia: comune.provincia.nome,
                    regione: comune.provincia.regione
                })).filter(town => town.population > 0 && !isNaN(town.lat) && !isNaN(town.lon));
                
                document.getElementById('locationStatus').textContent = `Caricati ${towns.length} comuni italiani`;
                
                // Inizializza i marker dopo il caricamento dei dati
                addTownMarkersToMap();
                
            } catch (error) {
                console.error('Errore nel caricamento dati:', error);
                document.getElementById('locationStatus').textContent = 'Errore caricamento dati. Usando dati di esempio.';
                
                // Usa dati di esempio in caso di errore
                towns = [
                    { name: "Milano", lat: 45.4642, lon: 9.1900, population: 1366000, provincia: "Milano", regione: "Lombardia" },
                    { name: "Roma", lat: 41.9028, lon: 12.4964, population: 2873000, provincia: "Roma", regione: "Lazio" },
                    { name: "Napoli", lat: 40.8518, lon: 14.2681, population: 967000, provincia: "Napoli", regione: "Campania" },
                    { name: "Torino", lat: 45.0703, lon: 7.6869, population: 886000, provincia: "Torino", regione: "Piemonte" },
                    { name: "Palermo", lat: 38.1157, lon: 13.3615, population: 676000, provincia: "Palermo", regione: "Sicilia" },
                    { name: "Firenze", lat: 43.7696, lon: 11.2558, population: 382000, provincia: "Firenze", regione: "Toscana" },
                    { name: "Bologna", lat: 44.4949, lon: 11.3426, population: 389000, provincia: "Bologna", regione: "Emilia-Romagna" },
                    { name: "Genova", lat: 44.4056, lon: 8.9463, population: 580000, provincia: "Genova", regione: "Liguria" },
                    { name: "Venezia", lat: 45.4408, lon: 12.3155, population: 261000, provincia: "Venezia", regione: "Veneto" },
                    { name: "Verona", lat: 45.4384, lon: 10.9916, population: 257000, provincia: "Verona", regione: "Veneto" }
                ];
                
                addTownMarkersToMap();
            }
        }

        // Centra la mappa sulla posizione dell'utente
        function centerMapOnUser() {
            if (userLocation) {
                const view = map.getView();
                view.setCenter(ol.proj.fromLonLat([userLocation.lon, userLocation.lat]));
                view.setZoom(12);
            }
        }

        // Aggiorna la posizione dell'utente sulla mappa
        function updateUserLocationOnMap(lat, lon, accuracy) {
            // Rimuovi i layer precedenti se esistono
            if (userMarker) {
                map.removeLayer(userMarker);
            }
            if (directionLine) {
                map.removeLayer(directionLine);
            }
            if (accuracyCircle) {
                map.removeLayer(accuracyCircle);
            }
            
            // Crea un nuovo marker per la posizione dell'utente
            userMarker = new ol.layer.Vector({
                source: new ol.source.Vector({
                    features: [
                        new ol.Feature({
                            geometry: new ol.geom.Point(ol.proj.fromLonLat([lon, lat]))
                        })
                    ]
                }),
                style: new ol.style.Style({
                    image: new ol.style.Circle({
                        radius: 8,
                        fill: new ol.style.Fill({ color: '#3498db' }),
                        stroke: new ol.style.Stroke({
                            color: '#ffffff',
                            width: 2
                        })
                    })
                })
            });
            
            map.addLayer(userMarker);
            
            // Aggiungi la lineetta di direzione (20 pixel)
            if (userHeading !== null) {
                updateDirectionLine();
            }
            
            // Aggiungi cerchio di accuratezza
            accuracyCircle = new ol.layer.Vector({
                source: new ol.source.Vector({
                    features: [
                        new ol.Feature({
                            geometry: new ol.geom.Circle(
                                ol.proj.fromLonLat([lon, lat]),
                                accuracy
                            )
                        })
                    ]
                }),
                style: new ol.style.Style({
                    stroke: new ol.style.Stroke({
                        color: 'rgba(0, 123, 255, 0.5)',
                        width: 2
                    }),
                    fill: new ol.style.Fill({
                        color: 'rgba(0, 123, 255, 0.1)'
                    })
                })
            });
            
            map.addLayer(accuracyCircle);
        }

        // Crea la lineetta di direzione (20 pixel)
        function createDirectionLine(lon, lat, heading) {
            const center = ol.proj.fromLonLat([lon, lat]);
            
            // Correzione: sottrai 90° per allineare correttamente la direzione
            const correctedHeading = (heading - 90 + 360) % 360;
            const angle = (360 - correctedHeading) * Math.PI / 180;
            
            // Calcola la lunghezza in metri equivalente a 20 pixel alla scala corrente
            const view = map.getView();
            const resolution = view.getResolution();
            const pixelLength = 20; // 20 pixel
            const meterLength = pixelLength * resolution;
            
            // Calcola il punto finale
            const endLon = lon + (meterLength * Math.sin(angle)) / (111320 * Math.cos(lat * Math.PI / 180));
            const endLat = lat + (meterLength * Math.cos(angle)) / 110540;
            
            const endPoint = ol.proj.fromLonLat([endLon, endLat]);
            
            return new ol.geom.LineString([center, endPoint]);
        }

        // Aggiorna la lineetta di direzione sulla mappa
        function updateDirectionLine() {
            if (!userLocation || userHeading === null) return;
            
            // Rimuovi la lineetta precedente
            if (directionLine) {
                map.removeLayer(directionLine);
            }
            
            // Crea una nuova lineetta di direzione
            directionLine = new ol.layer.Vector({
                source: new ol.source.Vector({
                    features: [
                        new ol.Feature({
                            geometry: createDirectionLine(userLocation.lon, userLocation.lat, userHeading)
                        })
                    ]
                }),
                style: new ol.style.Style({
                    stroke: new ol.style.Stroke({
                        color: '#e74c3c',
                        width: 3
                    })
                })
            });
            
            map.addLayer(directionLine);
        }

        // Aggiungi marker per i comuni sulla mappa
        function addTownMarkersToMap() {
            // Rimuovi i marker precedenti
            townMarkers.forEach(marker => {
                map.removeLayer(marker);
            });
            townMarkers = [];
            
            // Filtra i comuni in base alla popolazione minima
            const filteredTowns = towns.filter(town => town.population >= minPopulationSize);
            
            // Aggiungi i marker per ogni comune
            filteredTowns.forEach(town => {
                const marker = new ol.layer.Vector({
                    source: new ol.source.Vector({
                        features: [
                            new ol.Feature({
                                geometry: new ol.geom.Point(ol.proj.fromLonLat([town.lon, town.lat])),
                                name: town.name,
                                population: town.population,
                                provincia: town.provincia,
                                regione: town.regione
                            })
                        ]
                    }),
                    style: new ol.style.Style({
                        image: new ol.style.Circle({
                            radius: 6,
                            fill: new ol.style.Fill({ color: '#e74c3c' }),
                            stroke: new ol.style.Stroke({
                                color: '#ffffff',
                                width: 2
                            })
                        })
                    })
                });
                
                map.addLayer(marker);
                townMarkers.push(marker);
            });
        }

        // Aggiorna la visuale dal suolo
        function updateGroundView() {
            if (!userLocation || !userHeading) return;
            
            // Calcola la posizione dei marker nella visuale dal suolo
            updateGroundViewMarkers();
            
            // Aggiorna la freccia della bussola
            document.getElementById('compassArrow').style.transform = `rotate(${userHeading}deg)`;
            
            // Aggiorna le informazioni sulla posizione
            document.getElementById('currentLat').textContent = userLocation.lat.toFixed(6);
            document.getElementById('currentLon').textContent = userLocation.lon.toFixed(6);
            document.getElementById('currentHeading').textContent = Math.round(userHeading);
            
            // Aggiorna la lineetta di direzione sulla mappa
            updateDirectionLine();
        }

        // Calcola la posizione dei marker nella visuale dal suolo
        function updateGroundViewMarkers() {
            // Rimuovi i marker precedenti
            groundViewMarkers.forEach(marker => {
                if (marker.element && marker.element.parentNode) {
                    marker.element.parentNode.removeChild(marker.element);
                }
                if (marker.infoElement && marker.infoElement.parentNode) {
                    marker.infoElement.parentNode.removeChild(marker.infoElement);
                }
            });
            groundViewMarkers = [];
            
            const groundView = document.getElementById('groundView');
            
            // Filtra i comuni in base alla popolazione minima
            const filteredTowns = towns.filter(town => town.population >= minPopulationSize);
            
            filteredTowns.forEach(town => {
                // Calcola la distanza e l'heading verso il comune
                const distance = calculateDistance(
                    userLocation.lat, userLocation.lon, 
                    town.lat, town.lon
                );
                
                // Salta i comuni troppo lontani
                if (distance > maxDistance) return;
                
                let headingToTown = calculateBearing(
                    userLocation.lat, userLocation.lon, 
                    town.lat, town.lon
                );
                
                // Correzione: inverti l'heading per la visuale da terra
                headingToTown = (headingToTown + 180) % 360;
                
                // Calcola l'angolo relativo rispetto alla direzione dell'utente
                let relativeAngle = headingToTown - userHeading;
                if (relativeAngle < 0) relativeAngle += 360;
                if (relativeAngle > 360) relativeAngle -= 360;
                
                // Se il comune è dietro di noi, non mostrarlo
                if (relativeAngle > 90 && relativeAngle < 270) return;
                
                // Calcola la posizione X nel campo visivo (da -1 a 1)
                let xPosition = 0;
                if (relativeAngle <= 90) {
                    xPosition = Math.sin(relativeAngle * Math.PI / 180);
                } else {
                    xPosition = Math.sin((relativeAngle - 180) * Math.PI / 180);
                }
                
                // Calcola la posizione Y (più lontano = più in alto)
                const yPosition = 0.7 - (distance / maxDistance) * 0.5;
                
                // Crea il marker
                const marker = document.createElement('div');
                marker.className = 'marker';
                marker.style.left = `${50 + xPosition * 40}%`;
                marker.style.top = `${yPosition * 100}%`;
                
                // Crea l'info box
                const infoElement = document.createElement('div');
                infoElement.className = 'marker-info';
                infoElement.innerHTML = `
                    <strong>${town.name}</strong><br>
                    Distanza: ${distance.toFixed(1)} km<br>
                    Direzione: ${Math.round((headingToTown + 180) % 360)}°<br>
                    Abitanti: ${town.population.toLocaleString()}<br>
                    ${town.provincia} (${town.regione})
                `;
                infoElement.style.left = `${50 + xPosition * 40}%`;
                infoElement.style.top = `${yPosition * 100}%`;
                
                groundView.appendChild(marker);
                groundView.appendChild(infoElement);
                
                groundViewMarkers.push({
                    element: marker,
                    infoElement: infoElement,
                    town: town
                });
            });
        }

        // Calcola la distanza tra due punti (in km)
        function calculateDistance(lat1, lon1, lat2, lon2) {
            const R = 6371; // Raggio della Terra in km
            const dLat = (lat2 - lat1) * Math.PI / 180;
            const dLon = (lon2 - lon1) * Math.PI / 180;
            const a = 
                Math.sin(dLat/2) * Math.sin(dLat/2) +
                Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) * 
                Math.sin(dLon/2) * Math.sin(dLon/2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
            return R * c;
        }

        // Calcola l'heading tra due punti (in gradi)
        function calculateBearing(lat1, lon1, lat2, lon2) {
            const φ1 = lat1 * Math.PI / 180;
            const φ2 = lat2 * Math.PI / 180;
            const Δλ = (lon2 - lon1) * Math.PI / 180;
            
            const y = Math.sin(Δλ) * Math.cos(φ2);
            const x = Math.cos(φ1) * Math.sin(φ2) -
                      Math.sin(φ1) * Math.cos(φ2) * Math.cos(Δλ);
            const θ = Math.atan2(y, x);
            
            return (θ * 180 / Math.PI + 360) % 360;
        }

        // Gestione della geolocalizzazione
        function initGeolocation() {
            if (!navigator.geolocation) {
                document.getElementById('locationStatus').textContent = 
                    'Geolocalizzazione non supportata dal browser';
                return;
            }
            
            // Avvia il monitoraggio della posizione
            watchId = navigator.geolocation.watchPosition(
                position => {
                    if (debugMode) return; // Ignora in modalità DEBUG
                    
                    const lat = position.coords.latitude;
                    const lon = position.coords.longitude;
                    const accuracy = position.coords.accuracy;
                    
                    userLocation = { lat, lon };
                    
                    // Aggiorna la mappa
                    updateUserLocationOnMap(lat, lon, accuracy);
                    
                    // Aggiorna la visuale dal suolo
                    updateGroundView();
                    
                    document.getElementById('locationStatus').textContent = 
                        `Posizione: ${lat.toFixed(6)}, ${lon.toFixed(6)} | ${towns.length} comuni caricati`;
                },
                error => {
                    let errorMessage = 'Errore di geolocalizzazione: ';
                    switch(error.code) {
                        case error.PERMISSION_DENIED:
                            errorMessage += 'Permesso negato';
                            break;
                        case error.POSITION_UNAVAILABLE:
                            errorMessage += 'Posizione non disponibile';
                            break;
                        case error.TIMEOUT:
                            errorMessage += 'Timeout';
                            break;
                        default:
                            errorMessage += 'Errore sconosciuto';
                    }
                    document.getElementById('locationStatus').textContent = errorMessage;
                },
                {
                    enableHighAccuracy: true,
                    timeout: 10000,
                    maximumAge: 60000
                }
            );
        }

        // Gestione della bussola
        function initCompass() {
            if (!window.DeviceOrientationEvent) {
                document.getElementById('locationStatus').textContent += ' | Bussola non supportata';
                return;
            }
            
            // Richiedi l'autorizzazione per l'orientamento del dispositivo su iOS
            if (typeof DeviceOrientationEvent.requestPermission === 'function') {
                DeviceOrientationEvent.requestPermission()
                    .then(permissionState => {
                        if (permissionState === 'granted') {
                            window.addEventListener('deviceorientation', handleOrientation);
                        } else {
                            document.getElementById('locationStatus').textContent += 
                                ' | Autorizzazione bussola negata';
                        }
                    })
                    .catch(console.error);
            } else {
                // Per browser che non richiedono autorizzazione
                window.addEventListener('deviceorientation', handleOrientation);
            }
        }

        // Gestisce i dati dell'orientamento del dispositivo
        function handleOrientation(event) {
            if (debugMode) return; // Ignora in modalità DEBUG
            
            if (event.alpha !== null) {
                // Calcola l'heading corretto in base all'orientamento del dispositivo
                let heading = event.alpha; // alpha: orientamento rispetto al nord magnetico
                
                // Compensa per l'orientamento dello schermo
                switch (window.orientation) {
                    case 90:
                        heading = (heading + 90) % 360;
                        break;
                    case -90:
                        heading = (heading - 90) % 360;
                        break;
                    case 180:
                        heading = (heading + 180) % 360;
                        break;
                }
                
                userHeading = heading;
                updateGroundView();
            }
        }

        // Gestione della modalità DEBUG
        function initDebugMode() {
            const debugBtn = document.getElementById('debugBtn');
            
            debugBtn.addEventListener('click', function() {
                debugMode = !debugMode;
                
                if (debugMode) {
                    debugBtn.textContent = 'Disattiva DEBUG';
                    debugBtn.classList.add('active');
                    document.getElementById('locationStatus').textContent = 
                        'Modalità DEBUG attiva - Usa click per posizione, tasto destro per ruotare';
                    
                    // Imposta una posizione di default se non c'è
                    if (!userLocation) {
                        userLocation = { lat: 41.9028, lon: 12.4964 }; // Roma
                        updateUserLocationOnMap(userLocation.lat, userLocation.lon, 100);
                    }
                    
                    // Imposta un heading di default se non c'è
                    if (!userHeading) {
                        userHeading = 0;
                    }
                    
                    updateGroundView();
                } else {
                    debugBtn.textContent = 'Modalità DEBUG';
                    debugBtn.classList.remove('active');
                    document.getElementById('locationStatus').textContent = 
                        'Modalità normale - Usando GPS e bussola del dispositivo';
                }
            });
        }

        // Gestione degli slider
        function initSliders() {
            const minSizeSlider = document.getElementById('minSizeSlider');
            const minSizeValue = document.getElementById('minSizeValue');
            const maxDistanceSlider = document.getElementById('maxDistanceSlider');
            const maxDistanceValue = document.getElementById('maxDistanceValue');
            
            minSizeSlider.addEventListener('input', function() {
                minPopulationSize = parseInt(this.value);
                minSizeValue.textContent = minPopulationSize.toLocaleString();
                addTownMarkersToMap();
                updateGroundView();
            });
            
            maxDistanceSlider.addEventListener('input', function() {
                maxDistance = parseFloat(this.value);
                maxDistanceValue.textContent = maxDistance.toFixed(1);
                updateGroundView();
            });
        }

        // Inizializzazione dell'applicazione
        async function initApp() {
            initMap();
            initDebugMode();
            initSliders();
            
            // Carica i dati dei comuni
            await loadTownsData();
            
            // Inizializza geolocalizzazione e bussola dopo il caricamento dei dati
            initGeolocation();
            initCompass();
            
            // Centra la mappa dopo un breve ritardo per permettere il caricamento
            setTimeout(centerMapOnUser, 1000);
        }

        // Avvia l'applicazione quando la pagina è caricata
        window.addEventListener('load', initApp);
    </script>
</body>
</html>
